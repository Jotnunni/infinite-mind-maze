<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Endless Minimal Maze + Secret Exit</title>

  <meta name="viewport"
        content="width=device-width, initial-scale=1.0,
                 maximum-scale=1.0, user-scalable=no">

  <style>
    :root {
      --md3-dark-surface: #050608;
      --md3-dark-surface-variant: #181a1f;
      --md3-dark-primary: #7dd3ff;
      --md3-dark-on-primary: #00131c;
      --md3-dark-outline: #3b414c;
      --md3-dark-on-surface: #e1e4f0;
      --md3-dark-secondary: #b0c6ff;
      --md3-dark-shadow: rgba(0, 0, 0, 0.5);

      --md3-light-surface: #f8fafc;
      --md3-light-surface-variant: #e3e8f0;
      --md3-light-primary: #006494;
      --md3-light-on-primary: #ffffff;
      --md3-light-outline: #c0cad8;
      --md3-light-on-surface: #111827;
      --md3-light-secondary: #2563eb;
      --md3-light-shadow: rgba(15, 23, 42, 0.22);
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
                   "Segoe UI", sans-serif;
      height: 100%;
      overflow: hidden;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      user-select: none;
      touch-action: none;
    }

    body {
      opacity: 0;
      animation: bodyFadeIn 0.7s ease-out forwards;
    }

    @keyframes bodyFadeIn {
      from { opacity: 0; transform: scale(1.01); }
      to   { opacity: 1; transform: scale(1); }
    }

    body[data-theme="dark"] {
      background: radial-gradient(circle at top, #141726 0%, #050608 65%, #000 100%);
      color: var(--md3-dark-on-surface);
    }

    body[data-theme="light"] {
      background: radial-gradient(circle at top, #e0f2ff 0%, #f8fafc 60%, #e2e8f0 100%);
      color: var(--md3-light-on-surface);
    }

    #ui {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 10px 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 20;
      gap: 10px;
      backdrop-filter: blur(16px);
      transition: transform 0.3s ease, opacity 0.3s ease;
      transform: translateY(-10px);
      opacity: 0;
      animation: uiDropIn 0.6s ease-out 0.1s forwards;
    }

    @keyframes uiDropIn {
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    body[data-theme="dark"] #ui {
      background: linear-gradient(135deg,
        rgba(10, 12, 22, 0.92),
        rgba(15, 23, 42, 0.88)
      );
      box-shadow: 0 10px 30px var(--md3-dark-shadow);
    }

    body[data-theme="light"] #ui {
      background: linear-gradient(135deg,
        rgba(248, 250, 252, 0.96),
        rgba(226, 232, 240, 0.96)
      );
      box-shadow: 0 10px 30px var(--md3-light-shadow);
    }

    #leftCluster {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    #stageLabel {
      font-weight: 700;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      font-size: 11px;
      padding: 6px 10px;
      border-radius: 999px;
      transform-origin: center;
      transition: transform 0.12s ease, box-shadow 0.12s ease;
    }

    body[data-theme="dark"] #stageLabel {
      background: rgba(125, 211, 255, 0.1);
      color: var(--md3-dark-primary);
      border: 1px solid rgba(125, 211, 255, 0.5);
    }

    body[data-theme="light"] #stageLabel {
      background: rgba(37, 99, 235, 0.06);
      color: var(--md3-light-secondary);
      border: 1px solid rgba(37, 99, 235, 0.35);
    }

    .stage-bump {
      animation: stageBump 0.3s ease-out;
    }

    @keyframes stageBump {
      0% { transform: scale(1); }
      30% { transform: scale(1.08); }
      100% { transform: scale(1); }
    }

    #depthLabel {
      font-size: 10px;
      opacity: 0.8;
      padding: 4px 8px;
      border-radius: 999px;
      white-space: nowrap;
    }

    body[data-theme="dark"] #depthLabel {
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.6);
      color: #e5e7eb;
    }

    body[data-theme="light"] #depthLabel {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.7);
      color: #1f2933;
    }

    #toolsHud {
      flex: 1;
      font-size: 10px;
      opacity: 0.9;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      transition: opacity 0.18s ease;
    }

    #rightCluster {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #message {
      font-size: 10px;
      max-width: 150px;
      text-align: right;
      opacity: 0.9;
      transition: opacity 0.2s ease, transform 0.2s ease;
    }

    .message-highlight {
      transform: translateY(-1px);
      opacity: 1;
    }

    .md3-icon-button {
      border: none;
      cursor: pointer;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 11px;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
      outline: none;
    }

    body[data-theme="dark"] .md3-icon-button {
      background: rgba(15, 23, 42, 0.9);
      color: var(--md3-dark-on-surface);
      border: 1px solid rgba(148, 163, 184, 0.5);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.55);
    }

    body[data-theme="light"] .md3-icon-button {
      background: rgba(255, 255, 255, 0.96);
      color: var(--md3-light-on-surface);
      border: 1px solid rgba(148, 163, 184, 0.4);
      box-shadow: 0 4px 14px rgba(148, 163, 184, 0.5);
    }

    .md3-icon-button span.icon {
      font-size: 13px;
      display: inline-block;
      transform-origin: center;
      transition: transform 0.14s ease;
    }

    .md3-icon-button:hover {
      transform: translateY(-1px);
    }

    .md3-icon-button:active {
      transform: translateY(0);
      box-shadow: none;
    }

    .md3-icon-button:hover .icon {
      transform: rotate(-8deg);
    }

    #toolsPanelWrapper {
      position: fixed;
      top: 52px;
      right: 12px;
      z-index: 19;
      pointer-events: none;
    }

    #toolsPanel {
      max-width: min(360px, 90vw);
      max-height: min(60vh, 420px);
      overflow: auto;
      border-radius: 26px;
      padding: 14px 14px 10px;
      transform-origin: top right;
      transition: opacity 0.16s ease, transform 0.16s ease;
      pointer-events: auto;
    }

    body[data-theme="dark"] #toolsPanel {
      background: radial-gradient(circle at top left,
        #111827 0%, #020617 55%, #000 100%);
      border: 1px solid rgba(148, 163, 184, 0.6);
      box-shadow:
        0 18px 45px rgba(0, 0, 0, 0.9),
        inset 0 0 0 0.5px rgba(255, 255, 255, 0.03);
    }

    body[data-theme="light"] #toolsPanel {
      background: radial-gradient(circle at top left,
        #e5f0ff 0%, #f9fafb 55%, #e2e8f0 100%);
      border: 1px solid rgba(148, 163, 184, 0.7);
      box-shadow:
        0 18px 35px rgba(148, 163, 184, 0.7),
        inset 0 0 0 0.5px rgba(255, 255, 255, 0.8);
    }

    #toolsPanel.hidden {
      opacity: 0;
      transform: scale(0.96) translateY(-6px);
      pointer-events: none;
    }

    #toolsPanelTitle {
      font-size: 13px;
      font-weight: 700;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    #toolsPanelSubtitle {
      font-size: 11px;
      opacity: 0.9;
      margin-bottom: 10px;
    }

    .tool-item {
      padding: 8px 6px;
      border-radius: 14px;
      margin-bottom: 4px;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
    }

    body[data-theme="dark"] .tool-item {
      border: 1px solid rgba(51, 65, 85, 0.9);
      background: linear-gradient(135deg,
        rgba(15, 23, 42, 0.8),
        rgba(15, 23, 42, 0.3)
      );
    }

    body[data-theme="light"] .tool-item {
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: linear-gradient(135deg,
        rgba(241, 245, 249, 0.9),
        rgba(226, 232, 240, 0.5)
      );
    }

    .tool-item:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.3);
    }

    .tool-name {
      font-size: 11px;
      font-weight: 700;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 3px;
    }

    .tool-name span.badge {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 999px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    body[data-theme="dark"] .tool-name span.badge.stage {
      background: rgba(125, 211, 255, 0.16);
      color: var(--md3-dark-primary);
      border: 1px solid rgba(125, 211, 255, 0.45);
    }

    body[data-theme="light"] .tool-name span.badge.stage {
      background: rgba(37, 99, 235, 0.08);
      color: var(--md3-light-secondary);
      border: 1px solid rgba(37, 99, 235, 0.35);
    }

    body[data-theme="dark"] .tool-name span.badge.collect {
      background: rgba(52, 211, 153, 0.16);
      color: #6ee7b7;
      border: 1px solid rgba(52, 211, 153, 0.5);
    }

    body[data-theme="light"] .tool-name span.badge.collect {
      background: rgba(22, 163, 74, 0.06);
      color: #15803d;
      border: 1px solid rgba(22, 163, 74, 0.35);
    }

    body[data-theme="dark"] .tool-name span.badge.key {
      background: rgba(248, 250, 252, 0.06);
      color: #e5e7eb;
      border: 1px solid rgba(148, 163, 184, 0.7);
    }

    body[data-theme="light"] .tool-name span.badge.key {
      background: rgba(15, 23, 42, 0.04);
      color: #111827;
      border: 1px solid rgba(148, 163, 184, 0.6);
    }

    .tool-desc {
      font-size: 10px;
      opacity: 0.9;
    }

    #settingsPanelWrapper {
      position: fixed;
      top: 52px;
      left: 12px;
      z-index: 19;
      pointer-events: none;
    }

    #settingsPanel {
      max-width: min(320px, 90vw);
      max-height: min(60vh, 340px);
      overflow: auto;
      border-radius: 26px;
      padding: 14px 14px 10px;
      transform-origin: top left;
      transition: opacity 0.16s ease, transform 0.16s ease;
      pointer-events: auto;
    }

    body[data-theme="dark"] #settingsPanel {
      background: radial-gradient(circle at top left,
        #111827 0%, #020617 55%, #000 100%);
      border: 1px solid rgba(148, 163, 184, 0.6);
      box-shadow:
        0 18px 45px rgba(0, 0, 0, 0.9),
        inset 0 0 0 0.5px rgba(255, 255, 255, 0.03);
    }

    body[data-theme="light"] #settingsPanel {
      background: radial-gradient(circle at top left,
        #e5f0ff 0%, #f9fafb 55%, #e2e8f0 100%);
      border: 1px solid rgba(148, 163, 184, 0.7);
      box-shadow:
        0 18px 35px rgba(148, 163, 184, 0.7),
        inset 0 0 0 0.5px rgba(255, 255, 255, 0.8);
    }

    #settingsPanel.hidden {
      opacity: 0;
      transform: scale(0.96) translateY(-6px);
      pointer-events: none;
    }

    #settingsTitle {
      font-size: 13px;
      font-weight: 700;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .settings-section {
      margin-bottom: 10px;
    }

    .settings-label {
      font-size: 11px;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .settings-options {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .settings-chip {
      font-size: 10px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: transform 0.12s ease, box-shadow 0.12s ease,
                  background 0.12s ease, border-color 0.12s ease;
    }

    .settings-chip input {
      display: none;
    }

    body[data-theme="dark"] .settings-chip {
      border-color: rgba(148, 163, 184, 0.7);
      color: #e5e7eb;
      background: rgba(15, 23, 42, 0.8);
    }

    body[data-theme="light"] .settings-chip {
      border-color: rgba(148, 163, 184, 0.8);
      color: #111827;
      background: rgba(255, 255, 255, 0.7);
    }

    .settings-chip:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(15, 23, 42, 0.35);
    }

    body[data-theme="dark"] .settings-chip.active {
      border-color: rgba(125, 211, 255, 0.8);
      background: rgba(8, 47, 73, 0.9);
      color: #e0f2fe;
    }

    body[data-theme="light"] .settings-chip.active {
      border-color: rgba(37, 99, 235, 0.8);
      background: rgba(191, 219, 254, 0.9);
      color: #111827;
    }

    .settings-inline {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #wallColorInput {
      width: 42px;
      height: 24px;
      border-radius: 8px;
      border: none;
      padding: 0;
      background: transparent;
      cursor: pointer;
    }

    #soundToggle {
      cursor: pointer;
    }

    #game {
      position: absolute;
      top: 52px;
      left: 0;
      right: 0;
      bottom: 0;
      display: block;
      touch-action: none;
      animation: gameFadeIn 0.5s ease-out 0.2s forwards;
      opacity: 0;
    }

    @keyframes gameFadeIn {
      to { opacity: 1; }
    }

    #toolBar {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%) translateY(12px);
      z-index: 21;
      display: flex;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      backdrop-filter: blur(18px);
      max-width: 95vw;
      box-sizing: border-box;
      opacity: 0;
      animation: toolbarSlideUp 0.55s ease-out 0.25s forwards;
    }

    @keyframes toolbarSlideUp {
      to {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }
    }

    body[data-theme="dark"] #toolBar {
      background: rgba(15, 23, 42, 0.85);
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.7);
    }

    body[data-theme="light"] #toolBar {
      background: rgba(248, 250, 252, 0.9);
      box-shadow: 0 10px 28px rgba(148, 163, 184, 0.7);
      border: 1px solid rgba(148, 163, 184, 0.7);
    }

    .tool-btn {
      border: none;
      border-radius: 999px;
      padding: 8px 10px;
      min-width: 56px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2px;
      cursor: pointer;
      touch-action: manipulation;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease, opacity 0.12s ease;
      outline: none;
    }

    body[data-theme="dark"] .tool-btn {
      background: rgba(15, 23, 42, 0.95);
      color: #e5e7eb;
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.6);
    }

    body[data-theme="light"] .tool-btn {
      background: rgba(255, 255, 255, 0.95);
      color: #111827;
      box-shadow: 0 4px 12px rgba(148, 163, 184, 0.7);
    }

    .tool-btn span.key-label {
      font-size: 9px;
      opacity: 0.7;
    }

    .tool-btn:active {
      transform: scale(0.96);
      box-shadow: none;
    }

    .tool-btn:nth-child(1) { animation: toolPulse 3s ease-in-out infinite 0.0s; }
    .tool-btn:nth-child(2) { animation: toolPulse 3s ease-in-out infinite 0.2s; }
    .tool-btn:nth-child(3) { animation: toolPulse 3s ease-in-out infinite 0.4s; }

    @keyframes toolPulse {
      0%, 100% { transform: translateY(0) scale(1); }
      50%      { transform: translateY(-0.5px) scale(1.02); }
    }

    .tool-btn.cooldown {
      opacity: 0.55;
      cursor: default;
      filter: grayscale(0.3);
    }

    @media (max-width: 480px) {
      #message { display: none; }
      .tool-btn { padding: 7px 8px; }
    }

    /* GAME OVER / VICTORY OVERLAY */

    #gameOverOverlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 40;
      background: radial-gradient(circle at center,
                 rgba(15, 23, 42, 0.9),
                 rgba(0, 0, 0, 0.96));
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    #gameOverOverlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    #gameOverCard {
      max-width: 360px;
      width: 90vw;
      border-radius: 28px;
      padding: 20px 18px 18px;
      text-align: center;
      backdrop-filter: blur(20px);
      animation: gameOverPop 0.35s ease-out;
    }

    body[data-theme="dark"] #gameOverCard {
      background: radial-gradient(circle at top,
                  rgba(15, 23, 42, 0.98),
                  rgba(15, 23, 42, 0.96));
      border: 1px solid rgba(148, 163, 184, 0.7);
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.95);
      color: #e5e7eb;
    }

    body[data-theme="light"] #gameOverCard {
      background: radial-gradient(circle at top,
                  rgba(248, 250, 252, 0.98),
                  rgba(226, 232, 240, 0.98));
      border: 1px solid rgba(148, 163, 184, 0.9);
      box-shadow: 0 24px 48px rgba(15, 23, 42, 0.4);
      color: #111827;
    }

    #gameOverTitle {
      font-size: 18px;
      font-weight: 800;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    #gameOverSubtitle {
      font-size: 12px;
      opacity: 0.9;
      margin-bottom: 16px;
    }

    #gameOverHint {
      font-size: 10px;
      opacity: 0.8;
      margin-bottom: 18px;
    }

    #gameOverButton {
      border-radius: 999px;
      border: none;
      padding: 9px 18px;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
    }

    body[data-theme="dark"] #gameOverButton {
      background: linear-gradient(135deg, #22c55e, #4ade80);
      color: #022c22;
      box-shadow: 0 10px 30px rgba(21, 128, 61, 0.8);
    }

    body[data-theme="light"] #gameOverButton {
      background: linear-gradient(135deg, #16a34a, #4ade80);
      color: #f9fafb;
      box-shadow: 0 10px 26px rgba(22, 163, 74, 0.55);
    }

    #gameOverButton:hover {
      transform: translateY(-1px);
    }

    #gameOverButton:active {
      transform: translateY(0);
      box-shadow: none;
    }

    @keyframes gameOverPop {
      0%   { transform: scale(0.86); opacity: 0; }
      60%  { transform: scale(1.03); opacity: 1; }
      100% { transform: scale(1);    opacity: 1; }
    }

    /* START MENU OVERLAY */

    #startOverlay {
      position: fixed;
      inset: 0;
      z-index: 45;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at center,
                 rgba(15, 23, 42, 0.94),
                 rgba(0, 0, 0, 0.98));
      opacity: 1;
      pointer-events: auto;
      transition: opacity 0.3s ease;
    }

    body[data-theme="light"] #startOverlay {
      background: radial-gradient(circle at center,
                 rgba(241, 245, 249, 0.98),
                 rgba(148, 163, 184, 0.9));
    }

    #startOverlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #startCard {
      max-width: 380px;
      width: 90vw;
      border-radius: 28px;
      padding: 22px 20px 18px;
      text-align: center;
      backdrop-filter: blur(20px);
      animation: gameOverPop 0.35s ease-out;
    }

    body[data-theme="dark"] #startCard {
      background: radial-gradient(circle at top,
                  rgba(15, 23, 42, 0.98),
                  rgba(15, 23, 42, 0.96));
      border: 1px solid rgba(148, 163, 184, 0.7);
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.95);
      color: #e5e7eb;
    }

    body[data-theme="light"] #startCard {
      background: radial-gradient(circle at top,
                  rgba(248, 250, 252, 0.98),
                  rgba(226, 232, 240, 0.98));
      border: 1px solid rgba(148, 163, 184, 0.9);
      box-shadow: 0 24px 48px rgba(15, 23, 42, 0.4);
      color: #111827;
    }

    #startTitle {
      font-size: 18px;
      font-weight: 800;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      margin-bottom: 10px;
    }

    #startSubtitle {
      font-size: 12px;
      opacity: 0.9;
      margin-bottom: 16px;
    }

    #startHint {
      font-size: 10px;
      opacity: 0.8;
      margin-bottom: 18px;
    }

    #startButton {
      border-radius: 999px;
      border: none;
      padding: 9px 20px;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
    }

    body[data-theme="dark"] #startButton {
      background: linear-gradient(135deg, #38bdf8, #22d3ee);
      color: #022c22;
      box-shadow: 0 10px 30px rgba(6, 182, 212, 0.7);
    }

    body[data-theme="light"] #startButton {
      background: linear-gradient(135deg, #0284c7, #22d3ee);
      color: #f9fafb;
      box-shadow: 0 10px 26px rgba(14, 116, 144, 0.55);
    }

    #startButton:hover {
      transform: translateY(-1px);
    }

    #startButton:active {
      transform: translateY(0);
      box-shadow: none;
    }
  </style>
</head>
<body data-theme="dark">

<div id="ui">
  <div id="leftCluster">
    <div id="stageLabel">Stage 1</div>
    <div id="depthLabel">Depth 0%</div>
    <div id="toolsHud">Tools: None</div>
  </div>
  <div id="rightCluster">
    <div id="message">Press Start ¬∑ then WASD / swipe ¬∑ Q/E/Space or buttons</div>
    <button id="settingsToggle" class="md3-icon-button" type="button">
      <span class="icon">‚öôÔ∏è</span><span>Settings</span>
    </button>
    <button id="toolsToggle" class="md3-icon-button" type="button">
      <span class="icon">üß∞</span><span>Tools</span>
    </button>
    <button id="themeToggle" class="md3-icon-button" type="button">
      <span class="icon">üåô</span><span id="themeLabel">Dark</span>
    </button>
  </div>
</div>

<div id="settingsPanelWrapper">
  <div id="settingsPanel" class="hidden">
    <div id="settingsTitle">Settings</div>

    <div class="settings-section">
      <div class="settings-label">Difficulty</div>
      <div class="settings-options">
        <label class="settings-chip" data-diff="easy">
          <input type="radio" name="difficulty" value="easy">
          Easy
        </label>
        <label class="settings-chip" data-diff="normal">
          <input type="radio" name="difficulty" value="normal" checked>
          Normal
        </label>
        <label class="settings-chip" data-diff="hard">
          <input type="radio" name="difficulty" value="hard">
          Hard
        </label>
      </div>
    </div>

    <div class="settings-section">
      <div class="settings-label">Wall color</div>
      <div class="settings-inline">
        <input type="color" id="wallColorInput" value="#ffffff">
        <span style="font-size:10px;opacity:0.9;">Pick any color for the maze walls.</span>
      </div>
    </div>

    <div class="settings-section">
      <div class="settings-label">Sound</div>
      <div class="settings-inline">
        <input type="checkbox" id="soundToggle" checked>
        <span style="font-size:10px;opacity:0.9;">Enable sound effects</span>
      </div>
    </div>
  </div>
</div>

<div id="toolsPanelWrapper">
  <div id="toolsPanel" class="hidden">
    <div id="toolsPanelTitle">Tools Guide</div>
    <div id="toolsPanelSubtitle">
      Stage tools unlock automatically. Collect tools appear inside the maze as glowing diamonds.
    </div>

    <!-- tool items (unchanged) -->
    <div class="tool-item">
      <div class="tool-name">
        <span>Flashlight</span>
        <span class="badge stage">Stage 2</span>
      </div>
      <div class="tool-desc">
        Expands your visible radius around the player so you see more of the maze instead of only one tile ahead.
      </div>
    </div>

    <div class="tool-item">
      <div class="tool-name">
        <span>Compass</span>
        <span class="badge stage">Stage 3</span>
      </div>
      <div class="tool-desc">
        Small arrow at the top-left that points toward the hidden exit, without revealing its location on the map.
      </div>
    </div>

    <div class="tool-item">
      <div class="tool-name">
        <span>Heat Trail</span>
        <span class="badge stage">Stage 4</span>
      </div>
      <div class="tool-desc">
        Your last few steps glow softly on the floor, helping you understand where you came from and avoid going in circles.
      </div>
    </div>

    <div class="tool-item">
      <div class="tool-name">
        <span>Auto-Turn Helper</span>
        <span class="badge stage">Stage 5</span>
      </div>
      <div class="tool-desc">
        When you reach a dead-end, the message bar warns you so you do not waste time walking into walls.
      </div>
    </div>

    <div class="tool-item">
      <div class="tool-name">
        <span>Shadow Sense</span>
        <span class="badge stage">Stage 6</span>
      </div>
      <div class="tool-desc">
        Tiles directly behind you become faintly visible in darkness, helping you retreat without feeling completely blind.
      </div>
    </div>

    <div class="tool-item">
      <div class="tool-name">
        <span>Pulse Scanner</span>
        <span class="badge stage">Stage 2</span>
        <span class="badge key">Q / Button</span>
      </div>
      <div class="tool-desc">
        Sends a small pulse around you and permanently adds nearby floor tiles to your mental map so they stay visible in the dark. Unlocks at Stage 2.
      </div>
    </div>

    <div class="tool-item">
      <div class="tool-name">
        <span>Breadcrumbs</span>
        <span class="badge collect">Collect</span>
        <span class="badge key">Space / Button</span>
      </div>
      <div class="tool-desc">
        Drops small glowing markers on tiles you choose. Older markers slowly disappear after the limit is reached.
      </div>
    </div>

    <div class="tool-item">
      <div class="tool-name">
        <span>Flash Bomb</span>
        <span class="badge collect">Collect</span>
        <span class="badge key">E / Button</span>
      </div>
      <div class="tool-desc">
        Briefly floods a larger area with light. All tiles in that zone are visible during the flash, and some of them stay permanently in your mental map.
      </div>
    </div>

    <div class="tool-item">
      <div class="tool-name">
        <span>Wall Vibration</span>
        <span class="badge collect">Collect</span>
      </div>
      <div class="tool-desc">
        When you stand near a thin wall that hides a possible shortcut, the message hint changes to warn that a wall feels unusual.
      </div>
    </div>

    <div class="tool-item">
      <div class="tool-name">
        <span>Path Whisperer</span>
        <span class="badge collect">Collect</span>
      </div>
      <div class="tool-desc">
        Shows subtle text hints when your movement brings you closer to the hidden exit, like a quiet guidance system.
      </div>
    </div>

    <div class="tool-item">
      <div class="tool-name">
        <span>Memory Glyph</span>
        <span class="badge collect">Collect</span>
      </div>
      <div class="tool-desc">
        Every few steps, a randomly chosen visited tile becomes permanently visible, as if you drew it on a mental map.
      </div>
    </div>

    <div class="tool-item">
      <div class="tool-name">
        <span>Wall-X Vision</span>
        <span class="badge collect">Collect</span>
      </div>
      <div class="tool-desc">
        Makes nearby walls visible even in darkness, without revealing the floors, so you can ‚Äúfeel‚Äù the maze boundaries.
      </div>
    </div>

    <div class="tool-item">
      <div class="tool-name">
        <span>Micro-Compass</span>
        <span class="badge collect">Collect</span>
      </div>
      <div class="tool-desc">
        Adds a second arrow that points toward the nearest unexplored floor tile instead of the exit, encouraging exploration.
      </div>
    </div>
  </div>
</div>

<canvas id="game"></canvas>

<div id="toolBar">
  <button id="btnPulse" class="tool-btn" type="button">
    Pulse<span class="key-label">Q</span>
  </button>
  <button id="btnFlash" class="tool-btn" type="button">
    Flash<span class="key-label">E</span>
  </button>
  <button id="btnBreadcrumb" class="tool-btn" type="button">
    Mark<span class="key-label">Space</span>
  </button>
</div>

<!-- START MENU -->
<div id="startOverlay">
  <div id="startCard">
    <div id="startTitle">Infinite Mind Maze</div>
    <div id="startSubtitle">
      Start from the center. See almost nothing.  
      Earn tools by surviving deeper into the maze.
    </div>
    <div id="startHint">
      Choose difficulty and wall color in Settings if you like,  
      then press Start. You can move with WASD / arrows or swipe on mobile.
    </div>
    <button id="startButton" type="button">
      <span>‚ñ∂</span><span>Start Run</span>
    </button>
  </div>
</div>

<!-- SECRET EXIT VICTORY SCREEN -->
<div id="gameOverOverlay">
  <div id="gameOverCard">
    <div id="gameOverTitle">Secret Exit</div>
    <div id="gameOverSubtitle">
      You escaped the infinite maze.<br>
      Only those who reach Stage 8 ever find this path.
    </div>
    <div id="gameOverHint">
      Tap &ldquo;Play Again&rdquo; to regenerate a new maze.<br>
      Or press <strong>R</strong> on your keyboard.
    </div>
    <button id="gameOverButton" type="button">
      <span>‚ñ∂</span> <span>Play Again</span>
    </button>
  </div>
</div>

<script>
  const WALL = 0;
  const FLOOR = 1;

  const MAZE_COLS = 151;
  const MAZE_ROWS = 151;

  const baseStages = [
    { name: "Stage 1", mode: "forwardOnly", hasDarkness: true, flashlightRadius: 0,   zoom: 1.6,
      unlockMessage: "Only the next step is visible." },
    { name: "Stage 2", mode: "flashlight", hasDarkness: true, flashlightRadius: 3,   zoom: 1.3,
      unlockMessage: "Flashlight + Pulse unlocked." },
    { name: "Stage 3", mode: "flashlight", hasDarkness: true, flashlightRadius: 4,   zoom: 1.1,
      unlockMessage: "Compass unlocked." },
    { name: "Stage 4", mode: "flashlight", hasDarkness: true, flashlightRadius: 4.5, zoom: 1.0,
      unlockMessage: "Heat trail unlocked." },
    { name: "Stage 5", mode: "flashlight", hasDarkness: true, flashlightRadius: 5,   zoom: 0.9,
      unlockMessage: "Auto-turn helper unlocked." },
    { name: "Stage 6", mode: "flashlight", hasDarkness: true, flashlightRadius: 5.5, zoom: 0.85,
      unlockMessage: "Shadow sense unlocked." },
    { name: "Stage 7", mode: "flashlight", hasDarkness: true, flashlightRadius: 6,   zoom: 0.8,
      unlockMessage: "You feel the maze opening up." },
    { name: "Stage 8", mode: "flashlight", hasDarkness: true, flashlightRadius: 6.5, zoom: 0.75,
      unlockMessage: "A hidden exit is somewhere in this maze..." }
  ];

  const baseStageRadiusThresholds = [12, 24, 36, 48, 60, 72, 84, 96];

  let stages = baseStages.map(s => ({ ...s }));
  let stageRadiusThresholds = baseStageRadiusThresholds.slice();
  let difficulty = "normal";

  try {
    const savedDiff = localStorage.getItem('mazeDifficulty');
    if (savedDiff === 'easy' || savedDiff === 'normal' || savedDiff === 'hard') {
      difficulty = savedDiff;
    }
    const savedTheme = localStorage.getItem('mazeTheme');
    if (savedTheme === 'light' || savedTheme === 'dark') {
      document.body.dataset.theme = savedTheme;
    }
  } catch (e) {}

  const collectibleTypes = [
    "breadcrumbs",
    "flashBomb",
    "memoryGlyph",
    "wallVibration",
    "pathWhisperer",
    "wallXVision",
    "microCompass"
  ];

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const stageLabelEl = document.getElementById('stageLabel');
  const depthLabelEl = document.getElementById('depthLabel');
  const messageEl = document.getElementById('message');
  const toolsHudEl = document.getElementById('toolsHud');
  const toolsToggleBtn = document.getElementById('toolsToggle');
  const toolsPanel = document.getElementById('toolsPanel');
  const themeToggleBtn = document.getElementById('themeToggle');
  const themeLabelEl = document.getElementById('themeLabel');
  const settingsToggleBtn = document.getElementById('settingsToggle');
  const settingsPanel = document.getElementById('settingsPanel');
  const wallColorInput = document.getElementById('wallColorInput');
  const soundToggleInput = document.getElementById('soundToggle');
  const difficultyChips = document.querySelectorAll('.settings-chip');

  const btnPulse = document.getElementById('btnPulse');
  const btnFlash = document.getElementById('btnFlash');
  const btnBreadcrumb = document.getElementById('btnBreadcrumb');
  const pulseKeyLabel = btnPulse.querySelector('.key-label');
  const flashKeyLabel = btnFlash.querySelector('.key-label');

  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const gameOverButton = document.getElementById('gameOverButton');

  const startOverlay = document.getElementById('startOverlay');
  const startButton = document.getElementById('startButton');

  let cells = [];
  let rows = MAZE_ROWS;
  let cols = MAZE_COLS;

  let playerPos = { x: 0, y: 0 };
  let playerDir = { x: 0, y: -1 };
  let centerPos = { x: 0, y: 0 };
  let exitPos = { x: 0, y: 0 };

  let currentStageIndex = 0;

  let baseCellSize = 20;
  let cellSize = 20;
  let offsetX = 0;
  let offsetY = 0;

  let cameraPos = { x: 0, y: 0 };
  let cameraSpeed = 8;
  let currentZoom = 1;
  let zoomLerpSpeed = 4;
  let lastTimestamp = 0;

  let wallColorDark = "#ffffff";
  let wallColorLight = "#0f172a";
  let wallColor = wallColorDark;

  let floorColorDark = "#333333";
  let floorColorLight = "#e2e8f0";
  let floorColor = floorColorDark;

  let playerColorDark = "#00e5ff";
  let playerColorLight = "#006494";
  let playerColor = playerColorDark;

  let maxDistFromCenter = 1;

  let gameOver = false;
  let hasStarted = false;

  function setWallColor(color) {
    wallColor = color;
    wallColorInput.value = color;
  }

  const unlockedTools = {
    flashlight: false,
    compass: false,
    heatTrail: false,
    autoTurnHelper: false,
    shadowSense: false,

    pulseScanner: false,
    wallVibration: false,
    breadcrumbs: false,
    pathWhisperer: false,
    memoryGlyph: false,
    flashBomb: false,
    wallXVision: false,
    microCompass: false
  };

  let moveHistory = [];
  const HEAT_TRAIL_MAX = 20;

  let breadcrumbPositions = [];
  const BREADCRUMB_MAX = 10;

  let collectibles = [];

  let pulseActive = false;
  let pulseStartTime = 0;
  const PULSE_DURATION = 600;
  const PULSE_RADIUS = 4;

  let flashActive = false;
  let flashStartTime = 0;
  const FLASH_DURATION = 500;
  const FLASH_RADIUS = 8;

  const PULSE_COOLDOWN = 5000;
  const FLASH_COOLDOWN = 9000;
  let lastPulseUseTime = -1000000;
  let lastFlashUseTime = -1000000;

  let flashTempVisible = new Set();

  let lastExitDist = null;
  let visited = new Set();
  let memoryVisible = new Set();
  let stepsSinceLastMemory = 0;

  let audioCtx = null;
  let soundEnabled = true;

  function ensureAudioCtx() {
    if (!audioCtx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return null;
      audioCtx = new AC();
    }
    if (audioCtx.state === "suspended") audioCtx.resume();
    return audioCtx;
  }

  function playTone(freq, durationMs, type = "sine", vol = 0.15) {
    if (!soundEnabled) return;
    try {
      const ctxA = ensureAudioCtx();
      if (!ctxA) return;
      const now = ctxA.currentTime;
      const osc = ctxA.createOscillator();
      const gain = ctxA.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, now);
      gain.gain.setValueAtTime(vol, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + durationMs / 1000);
      osc.connect(gain);
      gain.connect(ctxA.destination);
      osc.start(now);
      osc.stop(now + durationMs / 1000 + 0.05);
    } catch (e) {}
  }

  function playStepSound()      { playTone(260 + Math.random() * 20, 40, "sine", 0.05); }
  function playStageUpSound()   { playTone(540, 140, "triangle", 0.18); setTimeout(() => playTone(720, 120, "triangle", 0.16), 70); }
  function playCollectSound()   { playTone(660, 130, "square", 0.18); }
  function playToolUseSound()   { playTone(400, 90, "sine", 0.12); }
  function playDeadEndSound()   { playTone(180, 180, "sine", 0.14); }
  function playWinSound()       { playTone(520, 180, "triangle", 0.18); setTimeout(()=>playTone(740,200,"triangle",0.16),100); setTimeout(()=>playTone(980,220,"triangle",0.16),200); }

  function setMessage(text) {
    messageEl.textContent = text;
    messageEl.classList.add("message-highlight");
    setTimeout(() => messageEl.classList.remove("message-highlight"), 200);
  }

  function keyFor(x, y) {
    return x + "," + y;
  }

  function updateToolsHud() {
    const names = [];

    if (unlockedTools.flashlight)     names.push("Flashlight");
    if (unlockedTools.pulseScanner)   names.push("PulseScanner");
    if (unlockedTools.compass)        names.push("Compass");
    if (unlockedTools.heatTrail)      names.push("HeatTrail");
    if (unlockedTools.autoTurnHelper) names.push("AutoTurn");
    if (unlockedTools.shadowSense)    names.push("ShadowSense");

    if (unlockedTools.breadcrumbs)    names.push("Breadcrumbs");
    if (unlockedTools.flashBomb)      names.push("FlashBomb");
    if (unlockedTools.memoryGlyph)    names.push("MemoryGlyph");
    if (unlockedTools.wallVibration)  names.push("WallVibration");
    if (unlockedTools.pathWhisperer)  names.push("PathWhisperer");
    if (unlockedTools.wallXVision)    names.push("WallXVision");
    if (unlockedTools.microCompass)   names.push("MicroCompass");

    toolsHudEl.style.opacity = 0.5;
    toolsHudEl.textContent = names.length ? "Tools: " + names.join(" ¬∑ ") : "Tools: None";
    setTimeout(() => toolsHudEl.style.opacity = 1, 120);
  }

  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
  }

  function applyDifficulty() {
    stages = baseStages.map(s => ({ ...s }));
    stageRadiusThresholds = baseStageRadiusThresholds.slice();

    let flashFactor = 1.0;
    let radiusFactor = 1.0;

    if (difficulty === "easy") {
      flashFactor = 1.4;
      radiusFactor = 0.8;
    } else if (difficulty === "hard") {
      flashFactor = 0.7;
      radiusFactor = 1.2;
    }

    stages.forEach(s => {
      if (typeof s.flashlightRadius === "number") {
        s.flashlightRadius *= flashFactor;
      }
    });

    stageRadiusThresholds = baseStageRadiusThresholds.map(r =>
      Math.max(4, Math.round(r * radiusFactor))
    );
  }

  function applyTheme(theme) {
    document.body.setAttribute('data-theme', theme);
    if (theme === 'light') {
      wallColor = wallColorLight;
      floorColor = floorColorLight;
      playerColor = playerColorLight;
      themeLabelEl.textContent = "Light";
      themeToggleBtn.querySelector('.icon').textContent = "‚òÄÔ∏è";
    } else {
      wallColor = wallColorDark;
      floorColor = floorColorDark;
      playerColor = playerColorDark;
      themeLabelEl.textContent = "Dark";
      themeToggleBtn.querySelector('.icon').textContent = "üåô";
    }
    wallColorInput.value = wallColor;
  }

  function generateBigMaze() {
    let w = cols;
    let h = rows;
    if (w % 2 === 0) w++;
    if (h % 2 === 0) h++;

    cols = w;
    rows = h;

    cells = Array.from({ length: rows }, () => Array(cols).fill(WALL));

    const cx = Math.floor(cols / 2);
    const cy = Math.floor(rows / 2);
    centerPos = { x: cx, y: cy };

    cells[cy][cx] = FLOOR;
    playerPos = { x: cx, y: cy };
    cameraPos = { x: cx, y: cy };

    const stack = [];
    stack.push({ x: cx, y: cy });

    const directions = [
      { x: 2, y: 0 },
      { x: -2, y: 0 },
      { x: 0, y: 2 },
      { x: 0, y: -2 }
    ];

    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    while (stack.length > 0) {
      const current = stack.pop();
      shuffleArray(directions);

      for (const d of directions) {
        const nx = current.x + d.x;
        const ny = current.y + d.y;

        if (nx > 0 && nx < cols - 1 && ny > 0 && ny < rows - 1 && cells[ny][nx] === WALL) {
          const mx = current.x + d.x / 2;
          const my = current.y + d.y / 2;
          cells[my][mx] = FLOOR;
          cells[ny][nx] = FLOOR;
          stack.push({ x: nx, y: ny });
        }
      }
    }

    const openChance = 0.35;
    for (let y = 1; y < rows - 1; y++) {
      for (let x = 1; x < cols - 1; x++) {
        if (cells[y][x] !== WALL) continue;

        const neighbors = [];
        if (cells[y - 1][x] === FLOOR) neighbors.push({ x, y: y - 1 });
        if (cells[y + 1][x] === FLOOR) neighbors.push({ x, y: y + 1 });
        if (cells[y][x - 1] === FLOOR) neighbors.push({ x: x - 1, y });
        if (cells[y][x + 1] === FLOOR) neighbors.push({ x: x + 1, y });

        if (neighbors.length === 2) {
          const n1 = neighbors[0];
          const n2 = neighbors[1];
          const sameRow = n1.y === n2.y && n1.y === y;
          const sameCol = n1.x === n2.x && n1.x === x;
          if ((sameRow || sameCol) && Math.random() < openChance) {
            cells[y][x] = FLOOR;
          }
        }
      }
    }

    let maxDistSq = -1;
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        if (cells[y][x] === FLOOR) {
          const dx = x - cx;
          const dy = y - cy;
          const distSq = dx * dx + dy * dy;
          if (distSq > maxDistSq) {
            maxDistSq = distSq;
            exitPos = { x, y };
          }
        }
      }
    }
    maxDistFromCenter = Math.sqrt(maxDistSq || 1);
    if (maxDistFromCenter < 1) maxDistFromCenter = 1;

    collectibles = [];
    const numCollectibles = collectibleTypes.length;
    const minRadius = 10;
    for (let i = 0; i < numCollectibles; i++) {
      let placed = false;
      let tries = 0;
      while (!placed && tries < 2000) {
        tries++;
        const x = randomInt(1, cols - 1);
        const y = randomInt(1, rows - 1);
        if (cells[y][x] !== FLOOR) continue;
        const dx = x - cx;
        const dy = y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < minRadius) continue;
        if (collectibles.some(c => c.x === x && c.y === y)) continue;

        collectibles.push({
          x,
          y,
          type: collectibleTypes[i],
          collected: false
        });
        placed = true;
      }
    }
  }

  function currentStage() {
    return stages[Math.min(currentStageIndex, stages.length - 1)];
  }

  function updateDepthLabel() {
    const dx = playerPos.x - centerPos.x;
    const dy = playerPos.y - centerPos.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const pct = Math.min(100, Math.round((dist / maxDistFromCenter) * 100));
    depthLabelEl.textContent = `Depth ${pct}%`;
  }

  function updateUnlocksForStage() {
    unlockedTools.flashlight     = currentStageIndex >= 1;
    unlockedTools.pulseScanner   = currentStageIndex >= 1;
    unlockedTools.compass        = currentStageIndex >= 2;
    unlockedTools.heatTrail      = currentStageIndex >= 3;
    unlockedTools.autoTurnHelper = currentStageIndex >= 4;
    unlockedTools.shadowSense    = currentStageIndex >= 5;
    updateToolsHud();
  }

  function updateStageLabelAndMessage() {
    const stage = currentStage();
    stageLabelEl.textContent = `Stage ${currentStageIndex + 1}`;
    stageLabelEl.classList.remove("stage-bump");
    void stageLabelEl.offsetWidth;
    stageLabelEl.classList.add("stage-bump");
    setMessage(stage.unlockMessage || "");
    updateUnlocksForStage();
    updateDepthLabel();
  }

  function maybeAdvanceStage() {
    if (currentStageIndex >= stageRadiusThresholds.length) return;
    const dx = playerPos.x - centerPos.x;
    const dy = playerPos.y - centerPos.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const threshold = stageRadiusThresholds[currentStageIndex];
    if (dist > threshold && currentStageIndex < stages.length - 1) {
      currentStageIndex++;
      playStageUpSound();
      updateStageLabelAndMessage();
    }
  }

  function resizeCanvas() {
    const uiHeight = document.getElementById('ui').offsetHeight || 52;
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight - uiHeight;
    baseCellSize = Math.min(canvas.width, canvas.height) / 20;
  }

  function isVisibleCell(x, y) {
    const stage = currentStage();
    const k = keyFor(x, y);

    if (flashTempVisible.has(k)) return true;
    if (memoryVisible.has(k)) return true;
    if (x === playerPos.x && y === playerPos.y) return true;

    const isAdjacent =
      (x === playerPos.x + 1 && y === playerPos.y) ||
      (x === playerPos.x - 1 && y === playerPos.y) ||
      (x === playerPos.x &&   y === playerPos.y + 1) ||
      (x === playerPos.x &&   y === playerPos.y - 1);

    if (isAdjacent && cells[y][x] === WALL) return true;

    const dx = x - playerPos.x;
    const dy = y - playerPos.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (unlockedTools.shadowSense) {
      const dot = dx * playerDir.x + dy * playerDir.y;
      if (dot < 0 && dist <= 2) return true;
    }

    if (unlockedTools.wallXVision && cells[y][x] === WALL && dist <= 2.2) {
      return true;
    }

    if (stage.mode === "forwardOnly") {
      const fx = playerPos.x + playerDir.x;
      const fy = playerPos.y + playerDir.y;
      return x === fx && y === fy;
    }

    if (!stage.hasDarkness) return true;
    return dist <= stage.flashlightRadius;
  }

  function drawCompassTo(target, cx, cy, len, color) {
    const dx = target.x - playerPos.x;
    const dy = target.y - playerPos.y;
    if (dx === 0 && dy === 0) return;
    const angle = Math.atan2(dy, dx);

    const ex = cx + Math.cos(angle) * len;
    const ey = cy + Math.sin(angle) * len;

    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(ex, ey);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(ex, ey);
    ctx.lineTo(
      ex - Math.cos(angle - Math.PI / 6) * 8,
      ey - Math.sin(angle - Math.PI / 6) * 8
    );
    ctx.lineTo(
      ex - Math.cos(angle + Math.PI / 6) * 8,
      ey - Math.sin(angle + Math.PI / 6) * 8
    );
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
    ctx.restore();
  }

  function drawCollectibles(timestamp) {
    for (let i = 0; i < collectibles.length; i++) {
      const c = collectibles[i];
      if (c.collected) continue;
      if (!isVisibleCell(c.x, c.y)) continue;

      const left = offsetX + c.x * cellSize;
      const top  = offsetY + c.y * cellSize;

      if (left + cellSize < 0 || left > canvas.width ||
          top + cellSize < 0 || top > canvas.height) continue;

      const t = timestamp * 0.005 + i;
      const pulsate = 0.75 + 0.2 * Math.sin(t);
      const size = cellSize * 0.35 * pulsate;

      ctx.save();
      ctx.translate(left + cellSize / 2, top + cellSize / 2);
      ctx.rotate(Math.PI / 4 + 0.1 * Math.sin(t * 0.4));
      const grad = ctx.createRadialGradient(0, 0, 1, 0, 0, size * 0.8);
      grad.addColorStop(0.0, "rgba(255, 212, 0, 0.95)");
      grad.addColorStop(1.0, "rgba(255, 212, 0, 0.05)");
      ctx.fillStyle = grad;
      ctx.fillRect(-size / 2, -size / 2, size, size);
      ctx.restore();
    }
  }

  function drawHeatTrail() {
    if (!unlockedTools.heatTrail) return;
    ctx.save();
    const isDark = document.body.dataset.theme === 'dark';
    ctx.fillStyle = isDark
      ? "rgba(0, 255, 255, 0.25)"
      : "rgba(37, 99, 235, 0.25)";
    for (const p of moveHistory) {
      if (!isVisibleCell(p.x, p.y)) continue;
      const left = offsetX + p.x * cellSize;
      const top  = offsetY + p.y * cellSize;
      ctx.fillRect(left + cellSize * 0.15, top + cellSize * 0.15,
                   cellSize * 0.7, cellSize * 0.7);
    }
    ctx.restore();
  }

  function drawBreadcrumbs() {
    if (!unlockedTools.breadcrumbs) return;
    ctx.save();
    ctx.fillStyle = "#4da6ff";
    for (const p of breadcrumbPositions) {
      if (!isVisibleCell(p.x, p.y)) continue;
      const cx = offsetX + (p.x + 0.5) * cellSize;
      const cy = offsetY + (p.y + 0.5) * cellSize;
      ctx.beginPath();
      ctx.arc(cx, cy, cellSize * 0.18, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawPulseEffect(timestamp) {
    if (pulseActive) {
      const t = timestamp - pulseStartTime;
      if (t > PULSE_DURATION) {
        pulseActive = false;
      } else {
        const alpha = 0.15 + 0.1 * Math.sin((t / PULSE_DURATION) * Math.PI);
        ctx.save();
        ctx.fillStyle = "rgba(0, 200, 255," + alpha + ")";
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            const dx = x - playerPos.x;
            const dy = y - playerPos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist <= PULSE_RADIUS && cells[y][x] === FLOOR) {
              const left = offsetX + x * cellSize;
              const top  = offsetY + y * cellSize;
              if (left + cellSize < 0 || left > canvas.width ||
                  top + cellSize < 0 || top > canvas.height) continue;
              ctx.fillRect(left, top, cellSize, cellSize);
            }
          }
        }
        ctx.restore();
      }
    }
  }

  function drawFlashEffect(timestamp) {
    if (flashActive) {
      const t = timestamp - flashStartTime;
      if (t > FLASH_DURATION) {
        flashActive = false;
        finalizeFlashTempArea();
      } else {
        let factor = 1 - t / FLASH_DURATION;
        factor = Math.max(0, Math.min(1, factor));
        const alpha = 0.25 * factor;

        ctx.save();
        ctx.fillStyle = "rgba(255, 255, 200," + alpha + ")";
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            const dx = x - playerPos.x;
            const dy = y - playerPos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist <= FLASH_RADIUS && cells[y][x] === FLOOR) {
              const left = offsetX + x * cellSize;
              const top  = offsetY + y * cellSize;
              if (left + cellSize < 0 || left > canvas.width ||
                  top + cellSize < 0 || top > canvas.height) continue;
              ctx.fillRect(left, top, cellSize, cellSize);
            }
          }
        }
        ctx.restore();
      }
    }
  }

  function findNearestUnvisited() {
    let best = null;
    let bestDistSq = Infinity;
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        if (cells[y][x] !== FLOOR) continue;
        const k = keyFor(x, y);
        if (visited.has(k)) continue;
        const dx = x - playerPos.x;
        const dy = y - playerPos.y;
        const distSq = dx * dx + dy * dy;
        if (distSq < bestDistSq) {
          bestDistSq = distSq;
          best = { x, y };
        }
      }
    }
    return best;
  }

  function draw(timestamp) {
    if (timestamp === undefined) timestamp = performance.now();
    const dt = lastTimestamp ? (timestamp - lastTimestamp) / 1000 : 0;
    lastTimestamp = timestamp;

    const stage = currentStage();

    const camLerp = Math.min(1, cameraSpeed * dt);
    cameraPos.x += (playerPos.x - cameraPos.x) * camLerp;
    cameraPos.y += (playerPos.y - cameraPos.y) * camLerp;

    const targetZoom = stage.zoom;
    const zoomFactor = Math.min(1, zoomLerpSpeed * dt);
    currentZoom += (targetZoom - currentZoom) * zoomFactor;

    cellSize = baseCellSize * currentZoom;
    offsetX = canvas.width  / 2 - (cameraPos.x + 0.5) * cellSize;
    offsetY = canvas.height / 2 - (cameraPos.y + 0.5) * cellSize;

    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        if (!isVisibleCell(x, y)) continue;

        const left   = offsetX + x * cellSize;
        const top    = offsetY + y * cellSize;
        const right  = left + cellSize;
        const bottom = top + cellSize;

        if (right < 0 || left > canvas.width || bottom < 0 || top > canvas.height) continue;

        if (cells[y][x] === WALL) {
          // First fill full cell with floor color, so around rounded corners
          // we see floor instead of black background.
          ctx.fillStyle = floorColor;
          ctx.fillRect(left, top, right - left, bottom - top);

          const baseRadius = cellSize * 0.28;

          const hasUp    = y > 0        && cells[y - 1][x] === WALL;
          const hasDown  = y < rows - 1 && cells[y + 1][x] === WALL;
          const hasLeft  = x > 0        && cells[y][x - 1] === WALL;
          const hasRight = x < cols - 1 && cells[y][x + 1] === WALL;

          const rTL = (!hasUp   && !hasLeft)  ? baseRadius : 0;
          const rTR = (!hasUp   && !hasRight) ? baseRadius : 0;
          const rBR = (!hasDown && !hasRight) ? baseRadius : 0;
          const rBL = (!hasDown && !hasLeft)  ? baseRadius : 0;

          ctx.fillStyle = wallColor;
          ctx.beginPath();

          ctx.moveTo(left + rTL, top);
          ctx.lineTo(right - rTR, top);
          if (rTR > 0) ctx.quadraticCurveTo(right, top, right, top + rTR);
          else ctx.lineTo(right, top);

          ctx.lineTo(right, bottom - rBR);
          if (rBR > 0) ctx.quadraticCurveTo(right, bottom, right - rBR, bottom);
          else ctx.lineTo(right, bottom);

          ctx.lineTo(left + rBL, bottom);
          if (rBL > 0) ctx.quadraticCurveTo(left, bottom, left, bottom - rBL);
          else ctx.lineTo(left, bottom);

          ctx.lineTo(left, top + rTL);
          if (rTL > 0) ctx.quadraticCurveTo(left, top, left + rTL, top);
          else ctx.lineTo(left, top);

          ctx.closePath();
          ctx.fill();
        } else {
          ctx.fillStyle = floorColor;
          ctx.fillRect(left, top, right - left, bottom - top);
        }
      }
    }

    drawCollectibles(timestamp);
    drawHeatTrail();
    drawBreadcrumbs();

    const pLeft = offsetX + playerPos.x * cellSize;
    const pTop  = offsetY + playerPos.y * cellSize;
    const r     = cellSize * 0.3;

    ctx.save();
    const glowRadius = r * (1.2 + 0.15 * Math.sin(timestamp * 0.004));
    const grad = ctx.createRadialGradient(
      pLeft + cellSize / 2, pTop + cellSize / 2, r * 0.2,
      pLeft + cellSize / 2, pTop + cellSize / 2, glowRadius
    );
    const isDark = document.body.dataset.theme === 'dark';
    grad.addColorStop(0, isDark ? "rgba(0, 229, 255,0.8)" : "rgba(0, 100, 148,0.9)");
    grad.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(pLeft + cellSize / 2, pTop + cellSize / 2, glowRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.beginPath();
    ctx.arc(pLeft + cellSize / 2, pTop + cellSize / 2, r, 0, Math.PI * 2);
    ctx.fillStyle = playerColor;
    ctx.fill();

    if (unlockedTools.compass) {
      drawCompassTo(exitPos, 40, 40, 24, "#ffdd88");
    }

    if (unlockedTools.microCompass) {
      const nearest = findNearestUnvisited();
      if (nearest) {
        drawCompassTo(nearest, 40, 70, 18, "#88ff88");
      }
    }

    drawPulseEffect(timestamp);
    drawFlashEffect(timestamp);
  }

  function getRemainingCooldown(lastTime, cooldown, now) {
    return Math.max(0, cooldown - (now - lastTime));
  }

  function isPulseReady(now) {
    return getRemainingCooldown(lastPulseUseTime, PULSE_COOLDOWN, now) <= 0;
  }

  function isFlashReady(now) {
    return getRemainingCooldown(lastFlashUseTime, FLASH_COOLDOWN, now) <= 0;
  }

  function updateCooldownUI(nowMs) {
    const now = nowMs || performance.now();

    const pulseRemaining = getRemainingCooldown(lastPulseUseTime, PULSE_COOLDOWN, now);
    const pulseReady = pulseRemaining <= 0 || !unlockedTools.pulseScanner;
    if (unlockedTools.pulseScanner) {
      if (!pulseReady) {
        const sec = (pulseRemaining / 1000).toFixed(1);
        pulseKeyLabel.textContent = sec + "s";
        btnPulse.disabled = true;
        btnPulse.classList.add("cooldown");
      } else {
        pulseKeyLabel.textContent = "Q";
        btnPulse.disabled = false;
        btnPulse.classList.remove("cooldown");
      }
    } else {
      pulseKeyLabel.textContent = "Q";
      btnPulse.disabled = false;
      btnPulse.classList.remove("cooldown");
    }

    const flashRemaining = getRemainingCooldown(lastFlashUseTime, FLASH_COOLDOWN, now);
    const flashReady = flashRemaining <= 0 || !unlockedTools.flashBomb;
    if (unlockedTools.flashBomb) {
      if (!flashReady) {
        const sec = (flashRemaining / 1000).toFixed(1);
        flashKeyLabel.textContent = sec + "s";
        btnFlash.disabled = true;
        btnFlash.classList.add("cooldown");
      } else {
        flashKeyLabel.textContent = "E";
        btnFlash.disabled = false;
        btnFlash.classList.remove("cooldown");
      }
    } else {
      flashKeyLabel.textContent = "E";
      btnFlash.disabled = false;
      btnFlash.classList.remove("cooldown");
    }
  }

  function loop(ts) {
    draw(ts);
    updateCooldownUI(ts);
    requestAnimationFrame(loop);
  }

  function wrapIndex(i, max) {
    if (i < 0) return max - 1;
    if (i >= max) return 0;
    return i;
  }

  function isDeadEnd(x, y) {
    let openCount = 0;
    const dirs = [
      { x: 1, y: 0 },
      { x: -1, y: 0 },
      { x: 0, y: 1 },
      { x: 0, y: -1 }
    ];
    for (const d of dirs) {
      const nx = wrapIndex(x + d.x, cols);
      const ny = wrapIndex(y + d.y, rows);
      if (cells[ny][nx] === FLOOR) openCount++;
    }
    return openCount <= 1;
  }

  function checkWallVibrationHint() {
    if (!unlockedTools.wallVibration) return;

    const dirs = [
      { x: 1, y: 0 },
      { x: -1, y: 0 },
      { x: 0, y: 1 },
      { x: 0, y: -1 }
    ];
    for (const d of dirs) {
      const wx = wrapIndex(playerPos.x + d.x, cols);
      const wy = wrapIndex(playerPos.y + d.y, rows);
      if (cells[wy][wx] !== FLOOR) continue;

      const fx = wrapIndex(wx + d.x, cols);
      const fy = wrapIndex(wy + d.y, rows);
      const bx = wrapIndex(playerPos.x - d.x, cols);
      const by = wrapIndex(playerPos.y - d.y, rows);

      if (cells[fy][fx] === FLOOR && cells[by][bx] === FLOOR) {
        setMessage("One wall nearby feels thin.");
        return;
      }
    }
  }

  function checkCollectiblePickup() {
    for (const c of collectibles) {
      if (c.collected) continue;
      if (c.x === playerPos.x && c.y === playerPos.y) {
        c.collected = true;
        unlockedTools[c.type] = true;
        playCollectSound();
        updateToolsHud();
        setMessage("Collected: " + c.type);
      }
    }
  }

  function updateVisitedAndMemory() {
    const k = keyFor(playerPos.x, playerPos.y);
    visited.add(k);

    if (unlockedTools.memoryGlyph) {
      stepsSinceLastMemory++;
      if (stepsSinceLastMemory >= 10) {
        stepsSinceLastMemory = 0;
        const seen = Array.from(visited);
        if (seen.length > 0) {
          const randomKey = seen[Math.floor(Math.random() * seen.length)];
          memoryVisible.add(randomKey);
        }
      }
    }
  }

  function updatePathWhispererHint() {
    if (!unlockedTools.pathWhisperer) return;

    const dx = exitPos.x - playerPos.x;
    const dy = exitPos.y - playerPos.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (lastExitDist == null) {
      lastExitDist = dist;
      return;
    }

    if (dist < lastExitDist) {
      setMessage("A quiet pull forward.");
    }

    lastExitDist = dist;
  }

  function checkSecretExit() {
    if (currentStageIndex < 7) return;
    if (playerPos.x === exitPos.x && playerPos.y === exitPos.y) {
      triggerGameWon();
    }
  }

  function triggerGameWon() {
    if (gameOver) return;
    gameOver = true;
    playWinSound();
    gameOverOverlay.classList.add('visible');
    setMessage("Secret exit found. Game over.");
  }

  function restartGame() {
    gameOver = false;
    hasStarted = true; // already started once
    gameOverOverlay.classList.remove('visible');
    init();
  }

  function tryMove(dx, dy) {
    if (!hasStarted || gameOver) return;
    if (dx === 0 && dy === 0) return;

    let nx = playerPos.x + dx;
    let ny = playerPos.y + dy;
    nx = wrapIndex(nx, cols);
    ny = wrapIndex(ny, rows);

    if (cells[ny][nx] === WALL) return;

    playerPos = { x: nx, y: ny };
    playerDir = { x: dx, y: dy };

    moveHistory.push({ x: nx, y: ny });
    if (moveHistory.length > HEAT_TRAIL_MAX) moveHistory.shift();

    playStepSound();
    updateVisitedAndMemory();
    checkCollectiblePickup();
    checkWallVibrationHint();
    updatePathWhispererHint();
    if (unlockedTools.autoTurnHelper && isDeadEnd(nx, ny)) {
      setMessage("Dead-end. Maybe turn back.");
      playDeadEndSound();
    }

    maybeAdvanceStage();
    updateDepthLabel();
    checkSecretExit();
  }

  function revealToMemory(radius) {
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const dx = x - playerPos.x;
        const dy = y - playerPos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist <= radius && cells[y][x] === FLOOR) {
          const k = keyFor(x, y);
          memoryVisible.add(k);
          visited.add(k);
        }
      }
    }
  }

  function revealFlashTemp(radius) {
    flashTempVisible.clear();
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const dx = x - playerPos.x;
        const dy = y - playerPos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist <= radius && cells[y][x] === FLOOR) {
          const k = keyFor(x, y);
          flashTempVisible.add(k);
          visited.add(k);
        }
      }
    }
  }

  function finalizeFlashTempArea() {
    const PERMANENT_FRACTION = 0.35;
    flashTempVisible.forEach(k => {
      if (Math.random() < PERMANENT_FRACTION) {
        memoryVisible.add(k);
      }
    });
    flashTempVisible.clear();
  }

  function usePulseScanner(nowOverride) {
    if (!hasStarted || gameOver) return;
    if (!unlockedTools.pulseScanner) {
      setMessage("Pulse scanner not unlocked yet.");
      return;
    }
    const now = nowOverride || performance.now();
    if (!isPulseReady(now)) {
      const remaining = getRemainingCooldown(lastPulseUseTime, PULSE_COOLDOWN, now);
      setMessage("Pulse cooling down: " + (remaining / 1000).toFixed(1) + "s");
      return;
    }
    lastPulseUseTime = now;

    pulseActive = true;
    pulseStartTime = now;
    revealToMemory(PULSE_RADIUS);
    playToolUseSound();
    setMessage("Nearby paths added to your memory map.");
  }

  function useFlashBomb(nowOverride) {
    if (!hasStarted || gameOver) return;
    if (!unlockedTools.flashBomb) {
      setMessage("Flash bomb not collected yet.");
      return;
    }
    const now = nowOverride || performance.now();
    if (!isFlashReady(now)) {
      const remaining = getRemainingCooldown(lastFlashUseTime, FLASH_COOLDOWN, now);
      setMessage("Flash cooling down: " + (remaining / 1000).toFixed(1) + "s");
      return;
    }
    lastFlashUseTime = now;

    flashActive = true;
    flashStartTime = now;
    revealFlashTemp(FLASH_RADIUS);
    playToolUseSound();
    setMessage("A large area is revealed. Some of it will stick in your memory.");
  }

  function dropBreadcrumb() {
    if (!hasStarted || gameOver) return;
    if (!unlockedTools.breadcrumbs) {
      setMessage("Breadcrumb tool not collected yet.");
      return;
    }
    breadcrumbPositions.push({ x: playerPos.x, y: playerPos.y });
    if (breadcrumbPositions.length > BREADCRUMB_MAX) {
      breadcrumbPositions.shift();
    }
    playToolUseSound();
    setMessage("Breadcrumb dropped.");
  }

  function startGameFromMenu() {
    if (hasStarted) return;
    hasStarted = true;
    startOverlay.classList.add('hidden');
    setMessage("Find your way out of the dark.");
  }

  document.addEventListener('keydown', (e) => {
    // Handle start menu first
    if (!hasStarted) {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        startGameFromMenu();
      }
      return;
    }

    if (gameOver) {
      if (e.key === 'r' || e.key === 'R') {
        e.preventDefault();
        restartGame();
      }
      return;
    }

    let dx = 0, dy = 0;

    switch (e.key) {
      case "ArrowUp":
      case "w":
      case "W": dy = -1; break;
      case "ArrowDown":
      case "s":
      case "S": dy = 1;  break;
      case "ArrowLeft":
      case "a":
      case "A": dx = -1; break;
      case "ArrowRight":
      case "d":
      case "D": dx = 1;  break;

      case "q":
      case "Q":
        usePulseScanner();
        return;
      case "e":
      case "E":
        useFlashBomb();
        return;
      case " ":
        e.preventDefault();
        dropBreadcrumb();
        return;
      default:
        return;
    }

    e.preventDefault();
    tryMove(dx, dy);
  });

  let touchStart = null;
  function getTouchPoint(e) {
    const t = e.touches?.[0] || e.changedTouches?.[0];
    if (!t) return null;
    return { x: t.clientX, y: t.clientY };
  }

  canvas.addEventListener("touchstart", (e) => {
    if (!hasStarted) return;
    const p = getTouchPoint(e);
    if (!p) return;
    touchStart = p;
    e.preventDefault();
  }, { passive: false });

  canvas.addEventListener("touchend", (e) => {
    if (!hasStarted) return;
    if (!touchStart) return;
    const p = getTouchPoint(e);
    if (!p) return;

    const dx = p.x - touchStart.x;
    const dy = p.y - touchStart.y;
    touchStart = null;

    if (dx * dx + dy * dy < 20 * 20) return;

    if (Math.abs(dx) > Math.abs(dy)) {
      tryMove(dx > 0 ? 1 : -1, 0);
    } else {
      tryMove(0, dy > 0 ? 1 : -1);
    }

    e.preventDefault();
  }, { passive: false });

  btnPulse.addEventListener('click', (e) => {
    e.preventDefault();
    const now = performance.now();
    if (!isPulseReady(now) && unlockedTools.pulseScanner) return;
    usePulseScanner(now);
  });

  btnFlash.addEventListener('click', (e) => {
    e.preventDefault();
    const now = performance.now();
    if (!isFlashReady(now) && unlockedTools.flashBomb) return;
    useFlashBomb(now);
  });

  btnBreadcrumb.addEventListener('click', (e) => {
    e.preventDefault();
    dropBreadcrumb();
  });

  toolsToggleBtn.addEventListener('click', () => {
    toolsPanel.classList.toggle('hidden');
  });

  settingsToggleBtn.addEventListener('click', () => {
    settingsPanel.classList.toggle('hidden');
  });

  themeToggleBtn.addEventListener('click', () => {
    const current = document.body.dataset.theme || 'dark';
    const next = current === 'dark' ? 'light' : 'dark';
    applyTheme(next);
    try { localStorage.setItem('mazeTheme', next); } catch (e) {}
  });

  function updateDifficultyChipStyles() {
    difficultyChips.forEach(chip => {
      const value = chip.getAttribute('data-diff');
      const input = chip.querySelector('input[type="radio"]');
      const active = (value === difficulty);
      if (input) input.checked = active;
      chip.classList.toggle('active', active);
    });
  }

  difficultyChips.forEach(chip => {
    chip.addEventListener('click', () => {
      const value = chip.getAttribute('data-diff');
      if (!value || value === difficulty) return;
      difficulty = value;
      updateDifficultyChipStyles();
      setMessage("Difficulty: " + value.charAt(0).toUpperCase() + value.slice(1));
      try { localStorage.setItem('mazeDifficulty', value); } catch (e) {}
      init();
    });
  });

  wallColorInput.addEventListener('input', (e) => {
    setWallColor(e.target.value);
  });

  soundToggleInput.addEventListener('change', (e) => {
    soundEnabled = e.target.checked;
    setMessage(soundEnabled ? "Sound enabled." : "Sound muted.");
  });

  document.addEventListener('click', (e) => {
    const target = e.target;

    const clickedToolsBtn = (target === toolsToggleBtn || toolsToggleBtn.contains(target));
    const clickedToolsPanel = toolsPanel.contains(target);

    const clickedSettingsBtn = (target === settingsToggleBtn || settingsToggleBtn.contains(target));
    const clickedSettingsPanel = settingsPanel.contains(target);

    if (!clickedToolsBtn && !clickedToolsPanel) {
      toolsPanel.classList.add('hidden');
    }
    if (!clickedSettingsBtn && !clickedSettingsPanel) {
      settingsPanel.classList.add('hidden');
    }
  });

  window.addEventListener("resize", resizeCanvas);

  gameOverButton.addEventListener('click', () => {
    restartGame();
  });

  gameOverOverlay.addEventListener('click', (e) => {
    if (e.target === gameOverOverlay) {
      restartGame();
    }
  });

  startButton.addEventListener('click', () => {
    startGameFromMenu();
  });

  function init() {
    applyDifficulty();
    const currentTheme = document.body.dataset.theme || 'dark';

    generateBigMaze();
    currentStageIndex = 0;
    visited.clear();
    memoryVisible.clear();
    moveHistory = [];
    breadcrumbPositions = [];
    lastExitDist = null;
    stepsSinceLastMemory = 0;
    flashTempVisible.clear();
    pulseActive = false;
    flashActive = false;
    lastPulseUseTime = -1000000;
    lastFlashUseTime = -1000000;
    gameOver = false;

    currentZoom = currentStage().zoom;
    cameraPos = { x: playerPos.x, y: playerPos.y };

    updateVisitedAndMemory();
    updateStageLabelAndMessage();
    applyTheme(currentTheme);

    updateDifficultyChipStyles();
    soundToggleInput.checked = soundEnabled;
    wallColorInput.value = wallColor;
    updateDepthLabel();

    resizeCanvas();
  }

  init();
  requestAnimationFrame(loop);
</script>

</body>
</html>
